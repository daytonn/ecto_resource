defmodule EctoResource do
  @moduledoc """
  This module represents the generic CRUD functionality that is boilerplate within
  Phoenix context files. It provides a DSL to easily generate the basic functions
  for a schema. This allows the context to focus on interesting, atypical implementations
  rather than the redundent, drifting crud functions.


      defmodule MyContext do
        use EctoResource

        using_repo(Repo) do
          resource(MySchema)
        end
      end

  This will generate the functions:

  `MyContext.change_my_schema(changable)`
    - changable object to generate changeset for

  `MyContext.create_my_schema(attributes)`
    - attributes

  `MyContext.delete_my_schema(deletable)`
    - deletable: Schema object to delete

  `MyContext.get_my_schema(id, options)`
    - id: id field for the schema value to be queried for
    - options:
      - preloads

  `MyContext.all_my_schemas(options)`
    - options:
      - preloads
      - order_by

  `MyContext.update_my_schema(updatable, attributes)`
    - updatable: Schema object to update
    - attributes

  There are also introspection functions to understand what is generated by the macro
  `MyContext.__resource__(:resources)` - A listing of the defined resources and their generated functions

  More granular control is available through three separate macros for read, write, and delete

      defmodule MyContext do
        use EctoResource

        using_repo(Repo) do
          read(MySchema)
        end
      end

  This will generate the functions:

  `MyContext.all_my_schemas(options)`
    - options:
      - preloads
      - order_by

  `MyContext.get_my_schema(id, options)`
    - id: id field for the schema value to be queried for
    - options:
      - preloads

  `MyContext.__resource__(:resources)` - A listing of the defined resources and their generated functions

      defmodule MyContext do
        use EctoResource

        using_repo(Repo) do
          write(MySchema)
        end
      end

  This will generate the functions:

  `MyContext.change_my_schema(changable)`
    - changable object to generate changeset for

  `MyContext.create_my_schema(attributes)`
    - attributes

  `MyContext.update_my_schema(updatable, attributes)`
    - updatable: Schema object to update
    - attributes

  `MyContext.__resource__(:resources)` - A listing of the defined resources and their generated functions

      defmodule MyContext do
        use EctoResource

        using_repo(Repo) do
          delete(MySchema)
        end
      end

  This will generate the functions:

  `MyContext.delete_my_schema(deletable)`
    - deletable: Schema object to delete

  `MyContext.__resource__(:resources)` - A listing of the defined resources and their generated functions
  """

  import Ecto.Query

  alias __MODULE__
  alias Inflex

  @actions %{
    all: 1,
    change: 1,
    create: 1,
    delete: 1,
    get: 2,
    update: 2
  }

  @spec change(module, Ecto.Schema.t()) :: Ecto.Changeset.t()
  def change(schema, changable) do
    changable
    |> schema.changeset(%{})
  end

  @spec create(Ecto.Repo.t(), module, map()) ::
          {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}
  def create(repo, schema, attributes) do
    schema
    |> struct()
    |> schema.changeset(attributes)
    |> repo.insert([])
  end

  @spec delete(Ecto.Repo.t(), Ecto.Schema.t()) ::
          {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}
  def delete(repo, deletable) do
    deletable
    |> repo.delete([])
  end

  @spec get(Ecto.Repo.t(), module, term(), term()) :: Ecto.Schema.t() | nil
  def get(repo, schema, id, options \\ []) do
    preloads = Keyword.get(options, :preloads, [])

    schema
    |> preload(^preloads)
    |> repo.get(id, [])
  end

  @spec all(Ecto.Repo.t(), module, term()) :: list(Ecto.Schema.t())
  def all(repo, schema, options \\ []) do
    preloads = Keyword.get(options, :preloads, [])
    order_by = Keyword.get(options, :order_by, [])

    schema
    |> preload(^preloads)
    |> order_by(^order_by)
    |> repo.all([])
  end

  @spec update(Ecto.Repo.t(), module, Ecto.Schema.t(), map()) ::
          {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}
  def update(repo, schema, updateable, attributes) do
    updateable
    |> schema.changeset(attributes)
    |> repo.update([])
  end

  def underscore_module_name(module) do
    module
    |> Macro.underscore()
    |> String.split("/")
    |> List.last()
  end

  defmacro __using__(_) do
    quote do
      import EctoResource, only: [using_repo: 2]
    end
  end

  defmacro using_repo(repo, do: block) do
    quote do
      Module.register_attribute(__MODULE__, :repo, [])
      Module.put_attribute(__MODULE__, :repo, unquote(repo))
      Module.register_attribute(__MODULE__, :resources, accumulate: true)
      import EctoResource, only: [resource: 1, read: 1, write: 1, delete: 1]
      unquote(block)
      def __resource__(:resources), do: @resources
      Module.delete_attribute(__MODULE__, :resources)
      Module.delete_attribute(__MODULE__, :repo)
    end
  end

  defp action_arity(verb), do: @actions[verb]

  defp accumulate_action_metadata(suffix, action, acc) do
    arity = action_arity(action)

    name =
      case action do
        :all -> :"#{action}_#{Inflex.pluralize(suffix)}"
        _ -> :"#{action}_#{suffix}"
      end

    Map.put(acc, action, %{
      description: "#{name}/#{arity}",
      name: name
    })
  end

  def resource_actions(suffix) do
    @actions
    |> Map.keys()
    |> Enum.reduce(%{}, &accumulate_action_metadata(suffix, &1, &2))
  end

  defmacro resource(schema) do
    quote bind_quoted: [schema: schema] do
      resources = EctoResource.resource_actions(EctoResource.underscore_module_name(schema))

      descriptions =
        resources
        |> Map.values()
        |> Enum.map(& &1.description)

      Module.put_attribute(
        __MODULE__,
        :resources,
        {@repo, schema, descriptions}
      )

      resources
      |> Map.keys()
      |> Enum.each(fn action ->
        resource_action = Map.put(%{}, action, resources[action])
        case resource_action do
          %{all: %{name: name}} ->
            def unquote(name)(options \\ []),
              do: EctoResource.all(@repo, unquote(schema), options)

          %{change: %{name: name}} ->
            def unquote(name)(changable),
              do: EctoResource.change(unquote(schema), changable)

          %{create: %{name: name}} ->
            def unquote(name)(attributes),
              do: EctoResource.create(@repo, unquote(schema), attributes)

          %{delete: %{name: name}} ->
            def unquote(name)(deletable),
              do: EctoResource.delete(@repo, deletable)

          %{get: %{name: name}} ->
            def unquote(name)(id, options \\ []),
              do: EctoResource.get(@repo, unquote(schema), id, options)

          %{update: %{name: name}} ->
            def unquote(name)(updatable, attributes),
              do: EctoResource.update(@repo, unquote(schema), updatable, attributes)

          _ ->
            nil
        end
      end)
    end
  end

  def read_actions(suffix) do
    @actions
    |> Map.take([:all, :get])
    |> Map.keys()
    |> Enum.reduce(%{}, &accumulate_action_metadata(suffix, &1, &2))
  end

  defmacro read(schema) do
    quote bind_quoted: [schema: schema] do
      read_actions = EctoResource.read_actions(EctoResource.underscore_module_name(schema))

      descriptions =
        read_actions
        |> Map.values()
        |> Enum.map(& &1.description)

      Module.put_attribute(
        __MODULE__,
        :resources,
        {@repo, schema, descriptions}
      )

      %{all: %{name: all_fn}, get: %{name: get_fn}} = read_actions

      def unquote(all_fn)(options \\ []),
        do: EctoResource.all(@repo, unquote(schema), options)

      def unquote(get_fn)(id, options \\ []),
        do: EctoResource.get(@repo, unquote(schema), id, options)
    end
  end

  def write_actions(suffix) do
    @actions
    |> Map.take([:change, :create, :update])
    |> Map.keys()
    |> Enum.reduce(%{}, &accumulate_action_metadata(suffix, &1, &2))
  end

  defmacro write(schema) do
    quote bind_quoted: [schema: schema] do
      write_actions = EctoResource.write_actions(EctoResource.underscore_module_name(schema))

      descriptions =
        write_actions
        |> Map.values()
        |> Enum.map(& &1.description)

      Module.put_attribute(
        __MODULE__,
        :resources,
        {@repo, schema, descriptions}
      )

      %{
        change: %{name: change_fn},
        create: %{name: create_fn},
        update: %{name: update_fn}
      } = write_actions

      def unquote(change_fn)(changable),
        do: EctoResource.change(unquote(schema), changable)

      def unquote(create_fn)(attributes),
        do: EctoResource.create(@repo, unquote(schema), attributes)

      def unquote(update_fn)(updatable, attributes),
        do: EctoResource.update(@repo, unquote(schema), updatable, attributes)
    end
  end

  defmacro delete(schema) do
    quote bind_quoted: [schema: schema] do
      suffix = EctoResource.underscore_module_name(schema)

      Module.put_attribute(
        __MODULE__,
        :resources,
        {@repo, schema, ["delete_#{suffix}/1"]}
      )

      def unquote(:"delete_#{suffix}")(deletable), do: EctoResource.delete(@repo, deletable)
    end
  end
end
